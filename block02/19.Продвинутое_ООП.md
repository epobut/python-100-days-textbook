## Продвинутое объектно-ориентированное программирование

Ранее мы рассмотрели некоторые основы объектно-ориентированного программирования в Python. В этом разделе мы продолжим обсуждение тем, связанных с объектно-ориентированным программированием.

### Видимость и декораторы свойств

Во многих объектно-ориентированных языках программирования атрибуты объекта обычно устанавливаются как приватные (private) или защищённые (protected) члены. Проще говоря, прямой доступ к этим атрибутам не разрешён. Методы объекта обычно публичны (public), потому что публичные методы — это сообщения, которые может принимать объект, а также интерфейс вызова, который объект предоставляет внешнему миру. Это называется видимостью доступа. В Python можно указать видимость доступа к атрибутам объекта, добавляя префикс подчёркивания к имени атрибута. Например, можно использовать `__name` для обозначения приватного атрибута, `_name` для обозначения защищённого атрибута, как показано в следующем коде.

```python
class Student:

    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def study(self, course_name):
        print(f'{self.__name} сейчас изучает {course_name}.')


stu = Student('Ван Дачуй', 20)
stu.study('программирование на Python')
print(stu.__name)  # AttributeError: 'Student' object has no attribute '__name'
```

Последняя строка приведённого выше кода вызовет исключение `AttributeError` (ошибка атрибута) с сообщением: `'Student' object has no attribute '__name'`. Из этого видно, что атрибут `__name`, начинающийся с `__`, является приватным и не может быть доступен напрямую вне класса, но в методе `study` внутри класса к этому атрибуту можно обращаться через `self.__name`. Следует отметить, что большинство людей, использующих язык Python, при определении классов обычно не делают атрибуты объектов приватными или защищёнными. Как говорится в известной цитате: "**We are all consenting adults here**" (мы все взрослые люди). Взрослые могут нести ответственность за свои действия, и нет необходимости ограничивать видимость доступа средствами самого языка Python. Фактически, большинство программистов считают, что **открытость лучше, чем закрытость**, и приватизация атрибутов объекта не является обязательной. Поэтому язык Python не устанавливает самые строгие ограничения на семантическом уровне. То есть, если вы хотите, в приведённом выше коде можно получить доступ к приватному атрибуту `__name` через `stu._Student__name`. Заинтересованные читатели могут попробовать это сами.

### Динамические атрибуты

Язык Python относится к динамическим языкам. Википедия определяет динамический язык как: "язык, который может изменять свою структуру во время выполнения, например, могут быть добавлены новые функции, объекты или даже код, существующие функции могут быть удалены или произведены другие структурные изменения". Динамические языки очень гибки. В настоящее время популярные Python и JavaScript являются динамическими языками. Кроме того, PHP, Ruby и другие также относятся к динамическим языкам, в то время как C, C++ и другие языки не являются динамическими.

В Python мы можем динамически добавлять атрибуты к объектам — это привилегия Python как языка с динамической типизацией, как показано в следующем коде. Следует напомнить, что методы объекта по сути также являются атрибутами объекта. Если отправить объекту сообщение, которое он не может принять, будет вызвано исключение `AttributeError`.

```python
class Student:

    def __init__(self, name, age):
        self.name = name
        self.age = age


stu = Student('Ван Дачуй', 20)
stu.sex = 'мужчина'  # Динамическое добавление атрибута sex к объекту студента
```

Если вы не хотите, чтобы атрибуты динамически добавлялись к объекту при его использовании, можно использовать магию `__slots__` языка Python. Для класса `Student` можно указать `__slots__ = ('name', 'age')` в классе, и тогда объекты класса `Student` смогут иметь только атрибуты `name` и `age`. Попытка динамически добавить другие атрибуты вызовет исключение, как показано в следующем коде.

```python
class Student:
    __slots__ = ('name', 'age')

    def __init__(self, name, age):
        self.name = name
        self.age = age


stu = Student('Ван Дачуй', 20)
# AttributeError: 'Student' object has no attribute 'sex'
stu.sex = 'мужчина'
```

### Статические методы и методы класса

Ранее все методы, которые мы определяли в классе, были методами объекта. Другими словами, эти методы — это сообщения, которые может принимать объект. Помимо методов объекта, в классе также могут быть статические методы и методы класса. Эти два типа методов — это сообщения, отправляемые классу, и между ними нет существенной разницы. В объектно-ориентированном мире всё является объектами, и каждый класс, который мы определяем, также является объектом. Статические методы и методы класса — это сообщения, отправляемые объектам класса. Так какие же сообщения отправляются непосредственно объектам класса?

Приведём пример: определим класс треугольника, который конструируется путём передачи длин трёх сторон, и предоставим методы для вычисления периметра и площади. Вычисление периметра и площади, безусловно, являются методами объекта треугольника, в этом нет сомнений. Но при создании объекта треугольника переданные длины трёх сторон не обязательно могут образовать треугольник. Для этого мы можем сначала написать метод для проверки того, могут ли заданные три стороны образовать треугольник. Такой метод, очевидно, не является методом объекта, потому что при вызове этого метода объект треугольника ещё не создан. Мы можем спроектировать такие методы как статические методы или методы класса. То есть такие методы являются не сообщениями, отправляемыми объекту треугольника, а сообщениями, отправляемыми классу треугольника, как показано в следующем коде.

```python
class Triangle(object):
    """треугольник"""         
    def __init__(self, a, b, c):
        """метод инициализации"""
        self.a = a
        self.b = b
        self.c = c 

    @staticmethod
    def is_valid(a, b, c):
        """проверка, могут ли три стороны образовать треугольник (статический метод)""" 
        return a + b > c and b + c > a and a + c > b

    # @classmethod
    # def is_valid(cls, a, b, c):
    #     """проверка, могут ли три стороны образовать треугольник (метод класса)"""
    #   return a + b > c and b + c > a and a + c > b

    def perimeter(self):
        """вычислить периметр"""
        return self.a + self.b + self.c   

    def area(self):
        """вычислить площадь"""   
        p = self.perimeter() / 2
        return (p * (p - self.a) * (p - self.b) * (p - self.c)) ** 0.5

```

Приведённый выше код использует декоратор `staticmethod` для объявления метода `is_valid` как статического метода класса `Triangle`. Если нужно объявить метод класса, можно использовать декоратор `classmethod` (как показано в строках 15-18 приведённого выше кода). Статические методы и методы класса можно вызывать напрямую, используя способ `Имя_класса.имя_метода`. Разница между ними в том, что первым параметром метода класса является сам объект класса, а у статического метода этого параметра нет. Подводя итог, **методы объекта, методы класса и статические методы можно вызывать через "Имя_класса.имя_метода". Разница заключается в том, является ли первый параметр метода обычным объектом, объектом класса или вообще отсутствует объект, принимающий сообщение**. Статический метод также обычно можно написать как независимую функцию, потому что он не привязан к конкретному объекту.

Здесь следует сделать дополнительное пояснение: мы можем добавить декоратор `property` (встроенный тип Python) к методам вычисления периметра и площади треугольника выше, и тогда `perimeter` и `area` класса треугольника станут двумя атрибутами. Доступ к ним будет осуществляться не через вызов методов, а через прямое получение с использованием способа доступа к атрибутам объекта. Изменённый код показан ниже.

```python
class Triangle(object):
    """треугольник"""

    def __init__(self, a, b, c):
        """метод инициализации"""
        self.a = a
        self.b = b
        self.c = c

    @staticmethod
    def is_valid(a, b, c):
        """проверка, могут ли три стороны образовать треугольник (статический метод)"""
        return a + b > c and b + c > a and a + c > b

    @property
    def perimeter(self):
        """вычислить периметр"""
        return self.a + self.b + self.c

    @property
    def area(self):
        """вычислить площадь"""
        p = self.perimeter / 2
        return (p * (p - self.a) * (p - self.b) * (p - self.c)) ** 0.5


t = Triangle(3, 4, 5)
print(f'периметр: {t.perimeter}')
print(f'площадь: {t.area}')
```

### Наследование и полиморфизм

Объектно-ориентированные языки программирования поддерживают создание новых классов на основе существующих классов, что сокращает написание повторяющегося кода. Класс, который предоставляет информацию для наследования, называется родительским классом (суперкласс, базовый класс). Класс, который получает информацию наследования, называется дочерним классом (производный класс, порождённый класс). Например, если мы определим класс студента и класс учителя, мы обнаружим, что у них много повторяющегося кода, и этот повторяющийся код — это общие атрибуты и поведение учителей и студентов как людей. Поэтому в такой ситуации мы должны сначала определить класс человека, а затем через наследование вывести из класса человека классы учителя и студента, как показано в следующем коде.

```python
class Person:
    """человек"""

    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def eat(self):
        print(f'{self.name} ест.')
    
    def sleep(self):
        print(f'{self.name} спит.')


class Student(Person):
    """студент"""
    
    def __init__(self, name, age):
        super().__init__(name, age)
    
    def study(self, course_name):
        print(f'{self.name} изучает {course_name}.')


class Teacher(Person):
    """учитель"""

    def __init__(self, name, age, title):
        super().__init__(name, age)
        self.title = title
    
    def teach(self, course_name):
        print(f'{self.name}{self.title} преподаёт {course_name}.')



stu1 = Student('Бай Юаньфан', 21)
stu2 = Student('Ди Женьцзе', 22)
tea1 = Teacher('Ву Цзэтянь', 35, 'доцент')
stu1.eat()
stu2.sleep()
tea1.eat()
stu1.study('программирование на Python')
tea1.teach('программирование на Python')
stu2.study('Введение в Data Science')
```

Синтаксис наследования заключается в том, что при определении класса в круглых скобках после имени класса указывается родительский класс текущего класса. Если при определении класса не указан его родительский класс, то по умолчанию родительским классом является класс `object`. Класс `object` — это класс верхнего уровня в Python, что означает, что все классы являются его подклассами — либо наследуют его напрямую, либо косвенно. Язык Python допускает множественное наследование, то есть класс может иметь одного или нескольких родительских классов. Вопрос множественного наследования мы обсудим более подробно позже. В методе инициализации дочернего класса мы можем вызвать метод инициализации родительского класса через `super().__init__()`. Функция `super` — это встроенная функция Python, специально предназначенная для получения объекта родительского класса текущего объекта. Из приведённого выше кода видно, что помимо получения атрибутов и методов, предоставленных родительским классом, через наследование, дочерний класс также может определять свои собственные уникальные атрибуты и методы. Поэтому дочерний класс обладает большими возможностями, чем родительский класс. В реальной разработке мы часто заменяем объект родительского класса объектом дочернего класса. Это обычное поведение в объектно-ориентированном программировании, также называемое "принципом подстановки Барбары Лисков" (Liskov Substitution Principle).

После того как дочерний класс наследует метод родительского класса, он может переопределить этот метод (переимплементировать его). Разные дочерние классы могут предоставить разные реализации одного и того же метода родительского класса. Такой метод во время выполнения программы будет демонстрировать полиморфное поведение (вызов одного и того же метода выполняет разные действия). Полиморфизм — это самая суть объектно-ориентированного программирования и, конечно, самая сложная часть для понимания и гибкого использования новичками. Мы рассмотрим этот концепт на специальном примере в следующей главе.

### Резюме

Python — это язык с динамической типизацией. Объекты в Python могут динамически получать атрибуты. Методы объекта на самом деле также являются атрибутами, просто атрибуту соответствует вызываемая функция. В объектно-ориентированном мире **всё является объектами**. Классы, которые мы определяем, также являются объектами, поэтому **классы также могут принимать сообщения**, и соответствующими методами являются методы класса или статические методы. Через наследование мы **можем создавать новые классы из существующих классов**, реализуя повторное использование кода существующих классов.
