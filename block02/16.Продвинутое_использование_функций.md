[← Предыдущий урок](15.Практическое_применение_функций.md) | [Следующий урок →](17.Продвинутые_применения_функций.md)
---

## Продвинутое использование функций

Продолжим исследование знаний, связанных с определением и использованием функций. Из предыдущего обучения мы узнали, что у функций есть независимые переменные (параметры) и зависимые переменные (возвращаемые значения), независимые переменные могут быть любого типа данных, зависимые переменные также могут быть любого типа данных. Возникает небольшой вопрос: можем ли мы использовать функцию в качестве параметра функции, использовать функцию в качестве возвращаемого значения функции? Сразу скажем вывод: **функции в Python — это "функции первого класса"**. Так называемые "функции первого класса" означают, что функция может быть присвоена переменной, функция может быть параметром функции, функция также может быть возвращаемым значением функции. Использование одной функции в качестве параметра или возвращаемого значения других функций обычно называется "функцией высшего порядка".

### Функции высшего порядка

Вернемся к ранее рассмотренному примеру: разработать функцию, принимающую любое количество параметров, для элементов типа `int` или `float` реализовать операцию суммирования. Немного изменим предыдущий код, чтобы сделать его более компактным, как показано ниже.

```python
def calc(*args, **kwargs):
    items = list(args) + list(kwargs.values())
    result = 0
    for item in items:
        if type(item) in (int, float):
            result += item
    return result
```

Если мы хотим, чтобы функция `calc` выше могла не только суммировать несколько параметров, но и выполнять больше или даже пользовательские бинарные операции, как это сделать? Приведенный выше код может только суммировать, потому что в функции используется оператор `+=`, что создает связь между функцией и операцией сложения. Если устранить эту связь, универсальность и гибкость функции станут лучше. Способ устранения связи — превратить оператор `+` в вызов функции и сделать его параметром функции, код показан ниже.

```python
def calc(init_value, op_func, *args, **kwargs):
    items = list(args) + list(kwargs.values())
    result = init_value
    for item in items:
        if type(item) in (int, float):
            result = op_func(result, item)
    return result
```

Обратите внимание, что в функцию выше добавлены два параметра: `init_value` представляет начальное значение операции, `op_func` представляет функцию бинарной операции. Для вызова измененной функции сначала определим функции для операций сложения и умножения, код показан ниже.

```python
def add(x, y):
    return x + y


def mul(x, y):
    return x * y
```

Если нужно выполнить операцию суммирования, можно вызвать функцию `calc` следующим образом.

```python
print(calc(0, add, 1, 2, 3, 4, 5))  # 15
```

Если нужно выполнить операцию произведения, можно вызвать функцию `calc` следующим образом.

```python
print(calc(1, mul, 1, 2, 3, 4, 5))  # 120 
```

Функция `calc` выше, превратив оператор в параметр функции, устранила связь с операцией сложения. Это очень умный и практичный прием программирования, но для начинающих может показаться трудным для понимания, рекомендую хорошо обдумать. Нужно отметить, что в приведенном выше коде есть существенная разница между передачей функции в качестве параметра в другую функцию и прямым вызовом функции: **при вызове функции после имени функции нужно поставить круглые скобки, а при передаче функции в качестве параметра достаточно только имени функции**.

Если мы заранее не определили функции `add` и `mul`, можно также использовать функции `add` и `mul` из модуля `operator` стандартной библиотеки Python, они представляют бинарные операции сложения и умножения соответственно, мы можем использовать их напрямую, код показан ниже.

```python
import operator

print(calc(0, operator.add, 1, 2, 3, 4, 5))  # 15
print(calc(1, operator.mul, 1, 2, 3, 4, 5))  # 120
```

Среди встроенных функций Python есть немало функций высшего порядка. Упомянутые ранее функции `filter` и `map` — это функции высшего порядка. Первая может реализовать фильтрацию элементов в последовательности, вторая — отображение элементов в последовательности. Например, если нужно удалить нечетные числа из списка целых чисел и возвести все четные числа в квадрат, получив новый список, можно использовать эти две функции, конкретный способ показан ниже.

```python
def is_even(num):
    """Проверить, является ли num четным числом"""
    return num % 2 == 0


def square(num):
    """Возвести в квадрат"""
    return num ** 2


old_nums = [35, 12, 8, 99, 60, 52]
new_nums = list(map(square, filter(is_even, old_nums)))
print(new_nums)  # [144, 64, 3600, 2704]
```

Конечно, для выполнения функциональности приведенного выше кода можно также использовать генератор списков, способ с генератором списков более простой и элегантный.

```python
old_nums = [35, 12, 8, 99, 60, 52]
new_nums = [num ** 2 for num in old_nums if num % 2 == 0]
print(new_nums)  # [144, 64, 3600, 2704]
```

Давайте обсудим еще одну встроенную функцию `sorted`, она может реализовать сортировку элементов контейнерных типов данных (например: списков, словарей и т.д.). Ранее мы говорили о методе `sort` типа `list`, он реализует сортировку элементов списка. Функция `sorted` функционально не отличается от метода `sort` списка, но она возвращает отсортированный объект списка, а не изменяет исходный список напрямую. Это называется **дизайн функции без побочных эффектов**, то есть вызов функции, помимо получения возвращаемого значения, не производит никакого другого влияния на состояние программы или внешнюю среду. При сортировке с помощью функции `sorted` можно настроить правила сортировки в виде функции высшего порядка, объясним это на примере ниже.

```python
old_strings = ['in', 'apple', 'zoo', 'waxberry', 'pear']
new_strings = sorted(old_strings)
print(new_strings)  # ['apple', 'in', 'pear', 'waxberry', 'zoo']
```

Приведенный выше код не должен быть незнакомым, но если хотим сортировать элементы списка по длине строки, а не по алфавитному порядку, можно передать в функцию `sorted` параметр с именем `key`, присвоив параметру `key` функцию `len`, получающую длину строки. Эту функцию мы упоминали на предыдущих уроках, код показан ниже.

```python
old_strings = ['in', 'apple', 'zoo', 'waxberry', 'pear']
new_strings = sorted(old_strings, key=len)
print(new_strings)  # ['in', 'zoo', 'pear', 'apple', 'waxberry']
```

> **Примечание**: У метода `sort` типа список также есть аналогичный параметр `key`, заинтересованные читатели могут попробовать самостоятельно.

### Lambda-функции

При использовании функций высшего порядка, если функция, используемая в качестве параметра или возвращаемого значения, очень проста — одна строка кода может выполнить задачу, и не нужно думать о повторном использовании функции, мы можем использовать lambda-функции. Lambda-функции в Python не имеют имени, поэтому многие также называют их **анонимными функциями**. Lambda-функция может иметь только одну строку кода, результат вычисления выражения в коде и есть возвращаемое значение этой анонимной функции. В предыдущем коде функции `is_even` и `square`, которые мы написали, содержат только одну строку кода, мы можем заменить их lambda-функциями, код показан ниже.

```python
old_nums = [35, 12, 8, 99, 60, 52]
new_nums = list(map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, old_nums)))
print(new_nums)  # [144, 64, 3600, 2704]
```

Из приведенного выше кода видно, что ключевое слово для определения lambda-функции — `lambda`, за ним следуют параметры функции, если параметров несколько, они разделяются запятыми; часть после двоеточия — это тело функции, обычно выражение, результат вычисления выражения и есть возвращаемое значение lambda-функции, писать ключевое слово `return` не нужно.

Ранее мы говорили, что функции в Python — это "функции первого класса", функцию можно напрямую присвоить переменной. После изучения lambda-функций некоторые функции, которые мы писали ранее, можно реализовать одной строкой кода. Посмотрите, понимаете ли вы функции для вычисления факториала и проверки простоты числа ниже.

```python
import functools
import operator

# Реализовать функцию вычисления факториала одной строкой кода
fac = lambda n: functools.reduce(operator.mul, range(2, n + 1), 1)

# Реализовать функцию проверки простоты одной строкой кода
is_prime = lambda x: all(map(lambda f: x % f, range(2, int(x ** 0.5) + 1)))

# Вызов Lambda-функций
print(fac(6))        # 720
print(is_prime(37))  # True
```

> **Подсказка 1**: Функция `reduce`, использованная выше, находится в модуле `functools` стандартной библиотеки Python, она может реализовать операцию свертки набора данных, аналогично ранее определенной функции `calc`. Первый параметр — функция, представляющая операцию, второй параметр — данные операции, третий параметр — начальное значение операции. Очевидно, что функция `reduce` также является функцией высшего порядка, она вместе с функциями `filter` и `map` образует три очень важных действия при обработке данных: **фильтрацию**, **отображение** и **свертку**.
>
> **Подсказка 2**: Lambda-функция для проверки простоты выше через функцию `range` создает диапазон от 2 до $\small{\sqrt{x}}$, проверяя, есть ли в этом диапазоне делители `x`. Функция `all` также является встроенной функцией Python. Если все булевы значения в переданной последовательности `True`, функция `all` возвращает `True`, иначе функция `all` возвращает `False`.

### Частичные функции

Частичная функция — это фиксация некоторых параметров функции для генерации новой функции, так что не нужно каждый раз при вызове функции передавать одни и те же параметры. В языке Python мы можем использовать функцию `partial` модуля `functools` для создания частичных функций. Например, функция `int` по умолчанию может преобразовывать строку как десятичное целое число. Если изменим ее параметр `base`, можем определить три новые функции для преобразования двоичных, восьмеричных, шестнадцатеричных строк в целые числа соответственно, код показан ниже.

```python
import functools

int2 = functools.partial(int, base=2)
int8 = functools.partial(int, base=8)
int16 = functools.partial(int, base=16)

print(int('1001'))    # 1001

print(int2('1001'))   # 9
print(int8('1001'))   # 513
print(int16('1001'))  # 4097
```

Не знаю, заметили ли вы, что первый параметр и возвращаемое значение функции `partial` — это функции, она обрабатывает переданную функцию в новую функцию и возвращает её. Через создание частичных функций мы можем, исходя из реального сценария использования, превратить исходную функцию в новую, более удобную в использовании функцию. Не знаю, кажется ли вам эта операция интересной.

### Заключение

Функции в Python — это функции первого класса, их можно присваивать переменным, а также использовать в качестве параметров и возвращаемых значений функций, что означает возможность использования функций высшего порядка в Python. Концепция функций высшего порядка не очень дружелюбна к новичкам, но она привносит гибкость в дизайн функций. Если функция, которую нам нужно определить, очень проста — всего одна строка кода, и не нужно имя функции для её повторного использования, мы можем использовать lambda-функции.

---
[← Предыдущий урок](15.Практическое_применение_функций.md) | [Следующий урок →](17.Продвинутые_применения_функций.md)
