[← Предыдущий урок](14.Функции_и_модули.md) | [Следующий урок →](16.Продвинутое_использование_функций.md)
---

## Практическое применение функций

### Пример 1: Случайный код подтверждения

Разработать функцию для генерации случайного кода подтверждения, состоящего из цифр и заглавных и строчных букв английского алфавита, длина может быть установлена через параметры.

```python
import random
import string

ALL_CHARS = string.digits + string.ascii_letters


def generate_code(*, code_len=4):
    """
    Генерация кода подтверждения указанной длины
    :param code_len: длина кода подтверждения (по умолчанию 4 символа)
    :return: случайная строка кода подтверждения, состоящая из больших и малых английских букв и цифр
    """
    return ''.join(random.choices(ALL_CHARS, k=code_len))
```

> **Примечание 1**: `digits` модуля `string` представляет строку цифр от 0 до 9 `'0123456789'`, `ascii_letters` модуля `string` представляет строку заглавных и строчных английских букв `'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`.
>
> **Примечание 2**: Функции `sample` и `choices` модуля `random` могут реализовать случайную выборку. `sample` реализует выборку без возврата, что означает, что выбранные элементы не повторяются; `choices` реализует выборку с возвратом, что означает, что могут быть повторно выбраны некоторые элементы. Первый параметр обеих функций представляет генеральную совокупность для выборки, а параметр `k` представляет объем выборки. Следует отметить, что параметр `k` функции `choices` является именованным ключевым параметром, при передаче параметра необходимо указать имя параметра.

Можно использовать следующий код для генерации 5 групп случайных кодов подтверждения для тестирования вышеуказанной функции.

```python
for _ in range(5):
    print(generate_code()) 
```

Вывод:

```
59tZ
QKU5
izq8
IBBb
jIfX
```

Или

```python
for _ in range(5):
    print(generate_code(code_len=6))
```

Вывод:

```
FxJucw
HS4H9G
0yyXfz
x7fohf
ReO22w
```

> **Примечание**: Параметр разработанной нами функции `generate_code` является именованным ключевым параметром, поскольку у него есть значение по умолчанию, можно не передавать ему значение, используя значение по умолчанию 4. Если нужно передать параметр функции, необходимо указать имя параметра `code_len`.

### Пример 2: Определение простых чисел

Разработать функцию для определения, является ли заданное положительное целое число больше 1 простым числом. Простое число — это положительное целое число (больше 1), которое делится только на 1 и на себя. Если положительное целое число $\small{N}$ больше 1 является простым числом, это означает, что между 2 и $\small{N-1}$ нет его делителей.

```python
def is_prime(num: int) -> bool:
    """
    Определить, является ли положительное целое число простым числом
    :param num: положительное целое число больше 1
    :return: если num простое число, возвращает True, иначе возвращает False
    """
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True
```

> **Примечание 1**: `: int` после параметра `num` функции `is_prime` выше используется для аннотации типа параметра. Хотя это не влияет на результат выполнения кода, но значительно повышает читаемость кода. Аналогично, `-> bool` после списка параметров используется для аннотации типа возвращаемого значения функции, это также не влияет на результат выполнения кода, но дает нам четкое понимание, что вызов функции даст булево значение — либо `True`, либо `False`.
>
> **Примечание 2**: Приведенный выше цикл не нужно выполнять от 2 до $\small{N-1}$, потому что если цикл доходит до $\small{\sqrt{N}}$ и не находит делителя $\small{N}$, то после $\small{\sqrt{N}}$ также не появится делитель $\small{N}$. Подумайте сами, почему это так.

### Пример 3: Наибольший общий делитель и наименьшее общее кратное

Разработать функции для вычисления наибольшего общего делителя и наименьшего общего кратного двух положительных целых чисел. Наибольший общий делитель $\small{x}$ и $\small{y}$ — это наибольшее целое число, которое одновременно делит $\small{x}$ и $\small{y}$. Если $\small{x}$ и $\small{y}$ взаимно просты, их наибольший общий делитель равен 1; наименьшее общее кратное $\small{x}$ и $\small{y}$ — это наименьшее положительное целое число, которое делится одновременно на $\small{x}$ и $\small{y}$. Если $\small{x}$ и $\small{y}$ взаимно просты, их наименьшее общее кратное равно $\small{x \times y}$. Нужно обратить внимание, что вычисление наибольшего общего делителя и наименьшего общего кратного — это две разные функциональности, их следует разработать как две функции, а не помещать обе функциональности в одну функцию.

```python
def lcm(x: int, y: int) -> int:
    """Найти наименьшее общее кратное"""
    return x * y // gcd(x, y)


def gcd(x: int, y: int) -> int:
    """Найти наибольший общий делитель"""
    while y % x != 0:
        x, y = y % x, x
    return x
```

> **Примечание**: Функции могут вызывать друг друга. Функция `lcm` для поиска наименьшего общего кратного вызывает функцию `gcd` для поиска наибольшего общего делителя, вычисляя наименьшее общее кратное через $\frac{x \times y}{ gcd(x, y)}$.

### Пример 4: Статистика данных

Предположим, что образцы данных сохранены в списке, разработать функцию для вычисления описательной статистической информации образцов данных. Описательная статистическая информация обычно включает: среднее арифметическое, медиану, размах (разность максимального и минимального значений), дисперсию, стандартное отклонение, коэффициент вариации и т.д., формулы вычисления следующие.

Выборочное среднее (sample mean):

$$
\bar{x} = \frac{\sum_{i=1}^{n}x_{i}}{n} = \frac{x_{1}+x_{2}+\cdots +x_{n}}{n}
$$

Выборочная дисперсия (sample variance):

$$
s^2 = \frac {\sum_{i=1}^{n}(x_i - \bar{x})^2} {n-1}
$$

Выборочное стандартное отклонение (sample standard deviation):

$$
s = \sqrt{\frac{\sum_{i=1}^{n}(x_i - \bar{x})^2}{n-1}}
$$

Коэффициент выборочной вариации (coefficient of sample variation):

$$
CV = \frac{s}{\bar{x}}
$$

```python
def ptp(data):
    """Размах (полный диапазон)"""
    return max(data) - min(data)


def mean(data):
    """Среднее арифметическое"""
    return sum(data) / len(data)


def median(data):
    """Медиана"""
    temp, size = sorted(data), len(data)
    if size % 2 != 0:
        return temp[size // 2]
    else:
        return mean(temp[size // 2 - 1:size // 2 + 1])


def var(data, ddof=1):
    """Дисперсия"""
    x_bar = mean(data)
    temp = [(num - x_bar) ** 2 for num in data]
    return sum(temp) / (len(temp) - ddof)


def std(data, ddof=1):
    """Стандартное отклонение"""
    return var(data, ddof) ** 0.5


def cv(data, ddof=1):
    """Коэффициент вариации"""
    return std(data, ddof) / mean(data)


def describe(data):
    """Вывести описательную статистическую информацию"""
    print(f'Среднее: {mean(data)}')
    print(f'Медиана: {median(data)}')
    print(f'Размах: {ptp(data)}')
    print(f'Дисперсия: {var(data)}')
    print(f'Стандартное отклонение: {std(data)}')
    print(f'Коэффициент вариации: {cv(data)}')
```

> **Примечание 1**: Медиана — это число, расположенное в середине после упорядочения данных по возрастанию или убыванию, она описывает средний уровень данных. Вычисление медианы делится на два случая: когда объем данных $n$ нечетный, медиана — это элемент, расположенный на позиции $\frac{n + 1}{2}$; когда объем данных $\small{n}$ четный, медиана — это среднее значение элементов на позициях $\frac{n}{2}$ и $\frac{n}{2} + 1$.
>
> **Примечание 2**: В функциях для вычисления дисперсии и стандартного отклонения есть параметр `ddof`, он представляет регулируемую степень свободы, значение по умолчанию — 1. При вычислении выборочной дисперсии и выборочного стандартного отклонения требуется корректировка степени свободы; если нужно вычислить генеральную дисперсию и генеральное стандартное отклонение, можно присвоить параметру `ddof` значение 0, то есть не требуется корректировка степени свободы.
>
> **Примечание 3**: Функция `describe` собирает вышеупомянутые инкапсулированные статистические функции вместе для вывода описательной статистической информации о данных. Фактически, в стандартной библиотеке Python есть модуль `statistics`, который уже инкапсулировал функции для получения описательной статистической информации, заинтересованные читатели могут изучить его самостоятельно.

### Пример 5: Случайный выбор номеров лотереи "Двойной цветной шар"

Мы рефакторим пример случайного выбора номеров лотереи "Двойной цветной шар", который мы обсуждали ранее (《Урок 09: Часто используемые структуры данных: списки-2》), инкапсулируя функциональность генерации случайных номеров и вывода одного набора номеров в две функции, затем через вызов функций реализуем функциональность выбора `N` наборов номеров.

```python
"""
Программа случайного выбора номеров двойного цветного шара

Author: 骆昊
Version: 1.3
"""
import random

RED_BALLS = [i for i in range(1, 34)]
BLUE_BALLS = [i for i in range(1, 17)]


def choose():
    """
    Сгенерировать набор случайных номеров
    :return: список с сохраненными случайными номерами
    """
    selected_balls = random.sample(RED_BALLS, 6)
    selected_balls.sort()
    selected_balls.append(random.choice(BLUE_BALLS))
    return selected_balls


def display(balls):
    """
    Форматированный вывод одного набора номеров
    :param balls: список с сохраненными случайными номерами
    """
    for ball in balls[:-1]:
        print(f'\033[031m{ball:0>2d}\033[0m', end=' ')
    print(f'\033[034m{balls[-1]:0>2d}\033[0m')


n = int(input('Сгенерировать сколько наборов номеров: '))
for _ in range(n):
    display(choose())
```

> **Примечание**: Посмотрите на строку кода `display(choose())`, здесь мы сначала получаем набор случайных номеров через функцию `choose`, затем возвращаемое значение функции `choose` используем как параметр функции `display`, через функцию `display` отображаем выбранные случайные номера. После рефакторинга логика кода очень ясна, читаемость кода стала лучше. Если кто-то инкапсулировал для вас эти две функции, и вы являетесь только вызывающим функции, на самом деле вам совершенно не нужно беспокоиться о внутренней реализации функций `choose` и `display`, вам нужно знать только, что вызов функции `choose` может сгенерировать набор случайных номеров, а вызов функции `display` с передачей списка выведет этот набор номеров. В будущем, когда мы будем использовать различные сторонние библиотеки Python, мы также совершенно не будем беспокоиться об их внутренней реализации, нам нужно знать только, какую функцию вызвать, чтобы решить проблему.

### Заключение

При написании кода, особенно при разработке коммерческих проектов, обязательно нужно осознанно **инкапсулировать относительно независимую и повторно используемую функциональность в функции**, так что и вы, и другие члены команды смогут использовать эту функциональность через вызов функций, сокращая повторяющуюся и скучную работу.

---
[← Предыдущий урок](14.Функции_и_модули.md) | [Следующий урок →](16.Продвинутое_использование_функций.md)
