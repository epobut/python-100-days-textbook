[← Предыдущий урок](16.Продвинутое_использование_функций.md) | Заключительный урок блока 1
---

## Продвинутые применения функций

В предыдущей главе мы изучили функции высшего порядка в Python, полагаю, у вас сформировалось более глубокое понимание определения и применения функций. В этой главе мы продолжим объяснять знания, связанные с функциями: особый синтаксис Python — декораторы, и рекурсивный вызов функций.

### Декораторы

В языке Python декоратор — это синтаксический феномен "**использования одной функции для декорирования другой функции и предоставления ей дополнительных возможностей**". Декоратор сам по себе является функцией, его параметром является декорируемая функция, его возвращаемым значением является функция с декорирующими возможностями. Из предыдущего описания вы уже поняли, что декоратор — это функция высшего порядка, его параметр и возвращаемое значение — это функции. Однако концепция декораторов все еще может быть головной болью для начинающих изучать языки программирования. Далее мы сначала объясним роль декораторов на простом примере. Предположим, есть две функции `download` и `upload` для загрузки и выгрузки файлов соответственно, как показано ниже.

```python
import random
import time


def download(filename):
    """Загрузить файл"""
    print(f'Начало загрузки {filename}.')
    time.sleep(random.random() * 6)
    print(f'{filename} загружен.')

    
def upload(filename):
    """Выгрузить файл"""
    print(f'Начало выгрузки {filename}.')
    time.sleep(random.random() * 8)
    print(f'{filename} выгружен.')

    
download('MySQL от удаления базы до побега.avi')
upload('Python от введения до госпитализации.pdf')
```

> **Примечание**: Приведенный выше код имитирует время, необходимое для загрузки и выгрузки файлов, с помощью приостановки на случайное время, фактически не выполняя загрузку и выгрузку файлов через интернет. Реализовать загрузку и выгрузку файлов через интернет на языке Python также очень просто, об этом мы расскажем позже.

Теперь есть новое требование: мы хотим знать, сколько времени занимает вызов функций `download` и `upload` для загрузки и выгрузки файлов. Как это реализовать? Полагаю, многие уже подумали: можно записать время в начале выполнения функции, записать время после завершения вызова функции, вычтя эти два времени, можно рассчитать время загрузки или выгрузки, код показан ниже.

```python
start = time.time()
download('MySQL от удаления базы до побега.avi')
end = time.time()
print(f'Затраченное время: {end - start:.2f}секунд')
start = time.time()
upload('Python от введения до госпитализации.pdf')
end = time.time()
print(f'Затраченное время: {end - start:.2f}секунд')
```

С помощью приведенного выше кода мы можем записать время, затраченное на загрузку и выгрузку файлов, но не знаю, заметили ли вы, что код для записи времени, вычисления и отображения времени выполнения — повторяющийся. Люди с опытом программирования знают, что **повторяющийся код — корень всех зол**. Есть ли способ записать время выполнения функции простым и элегантным способом без написания повторяющегося кода? В языке Python декораторы — лучший выбор для решения таких проблем. С помощью синтаксиса декораторов мы можем инкапсулировать функциональность измерения времени, не связанную с исходной бизнес-логикой (загрузка и выгрузка), в функцию. Если функциям `upload` и `download` нужно записывать время, мы просто применяем декоратор к этим двум функциям. Как упоминалось выше, декоратор — это функция высшего порядка, его параметр и возвращаемое значение — это функции. Назовем декоратор для записи времени `record_time`, тогда его общая структура должна быть такой, как в коде ниже.

```python
def record_time(func):
    
    def wrapper(*args, **kwargs):
        
        result = func(*args, **kwargs)
        
        return result
    
    return wrapper
```

Полагаю, вы заметили, что параметр `func` функции `record_time` представляет декорируемую функцию, определенная внутри функция `wrapper` — это функция с декорирующими возможностями, она выполнит декорируемую функцию `func` и должна вернуть возвращаемое значение выполнения функции. Не знаю, заметили ли вы, что в коде выше я оставил две пустые строки в строках 4 и 6, что означает, что мы можем добавить код в этих местах для реализации дополнительных функций. Функция `record_time` в конце вернет эту функцию `wrapper` с декорирующими возможностями и заменит ею исходную функцию `func`. После того как исходная функция `func` будет декорирована функцией `record_time`, при её вызове фактически вызывается функция `wrapper`, поэтому и получаются дополнительные возможности. Параметры функции `wrapper` особенные: поскольку мы хотим использовать `wrapper` для замены исходной функции `func`, но мы не знаем, какие параметры примет исходная функция `func`, мы используем переменные параметры и ключевые параметры для приема всех параметров, затем при вызове `func` передаем их все без изменений. Здесь еще нужно подчеркнуть, что язык Python поддерживает вложенное определение функций, как показано выше, мы можем определить функцию `wrapper` внутри функции `record_time`, эта операция не поддерживается во многих языках программирования.

Поняв эту структуру, мы можем добавить функциональность записи времени в этот декоратор, код показан ниже.

```python
import time


def record_time(func):

    def wrapper(*args, **kwargs):
        # Записать время начала перед выполнением декорируемой функции
        start = time.time()
        # Выполнить декорируемую функцию и получить возвращаемое значение
        result = func(*args, **kwargs)
        # Записать время окончания после выполнения декорируемой функции
        end = time.time()
        # Вычислить и отобразить время выполнения декорируемой функции
        print(f'{func.__name__} время выполнения: {end - start:.2f}секунд')
        # Вернуть возвращаемое значение декорируемой функции
        return result
    
    return wrapper
```

Хотя написание декоратора требует усилий, это операция, которая решает проблему раз и навсегда. В будущем, когда будет необходимость записывать время выполнения функций, достаточно просто добавить вышеуказанный декоратор. Использовать декоратор можно двумя способами: первый способ — напрямую вызвать функцию декоратора, передав декорируемую функцию и получив возвращаемое значение, мы можем использовать это возвращаемое значение для замены исходной функции, тогда при вызове уже будут получены дополнительные возможности, предоставленные декоратором (запись времени выполнения), попробуйте код ниже и все поймете.

```python
download = record_time(download)
upload = record_time(upload)
download('MySQL от удаления базы до побега.avi')
upload('Python от введения до госпитализации.pdf')
```

В Python есть более удобный **синтаксический сахар** для использования декораторов (синтаксис, добавленный в язык программирования, который не влияет на функциональность языка, но делает использование более удобным, а читаемость кода — лучше, мы называем его "синтаксическим сахаром" или "сахарным синтаксисом"). Можно использовать `@функция_декоратора`, поместив функцию декоратора непосредственно над декорируемой функцией, эффект будет таким же, как в коде выше. Приведем полный код, чтобы вы могли еще раз посмотреть, как мы определяем и используем декораторы.

```python
import random
import time


def record_time(func):

    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f'{func.__name__} время выполнения: {end - start:.2f}секунд')
        return result

    return wrapper


@record_time
def download(filename):
    print(f'Начало загрузки {filename}.')
    time.sleep(random.random() * 6)
    print(f'{filename} загружен.')


@record_time
def upload(filename):
    print(f'Начало выгрузки {filename}.')
    time.sleep(random.random() * 8)
    print(f'{filename} выгружен.')


download('MySQL от удаления базы до побега.avi')
upload('Python от введения до госпитализации.pdf')
```

В приведенном выше коде мы через синтаксический сахар декоратора добавили декоратор к функциям `download` и `upload`. Декорированные функции `download` и `upload` фактически являются функцией `wrapper`, которую мы возвращаем в декораторе. Вызов их фактически является вызовом функции `wrapper`, поэтому появилась функциональность записи времени выполнения функции.

Если в некоторых местах кода мы хотим убрать действие декоратора и выполнить исходную функцию, при определении функции декоратора нужно проделать небольшую дополнительную работу. Функция `wraps` модуля `functools` стандартной библиотеки Python также является декоратором, мы помещаем её над функцией `wrapper`, этот декоратор может помочь сохранить функцию до декорирования, так что при необходимости отменить декоратор можно через атрибут `__wrapped__` декорированной функции получить функцию до декорирования.

```python
import random
import time

from functools import wraps


def record_time(func):

    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f'{func.__name__} время выполнения: {end - start:.2f}секунд')
        return result

    return wrapper


@record_time
def download(filename):
    print(f'Начало загрузки {filename}.')
    time.sleep(random.random() * 6)
    print(f'{filename} загружен.')


@record_time
def upload(filename):
    print(f'Начало выгрузки {filename}.')
    time.sleep(random.random() * 8)
    print(f'{filename} выгружен.')


# Вызов декорированной функции записывает время выполнения
download('MySQL от удаления базы до побега.avi')
upload('Python от введения до госпитализации.pdf')
# Отмена действия декоратора не записывает время выполнения
download.__wrapped__('MySQL необходимые знания.pdf')
upload.__wrapped__('Python от новичка до мастера.pdf')
```

**Сама функция декоратора также может быть параметризована**, проще говоря, декоратор также может быть настроен через параметры, передаваемые вызывающей стороной. Эту тему мы объясним позже, когда она нам понадобится.

### Рекурсивный вызов

Python допускает вложенное определение функций, а также взаимный вызов функций, причем функция может прямо или косвенно вызывать сама себя. Когда функция вызывает сама себя, это называется рекурсивным вызовом. Какова польза от рекурсивного вызова? В реальности многие проблемы по своему определению являются рекурсивными, например, факториал, о котором мы говорили ранее. Факториал неотрицательного целого числа `N` — это `N`, умноженное на факториал `N-1`, то есть $\small{N! = N \times (N-1)!}$. В определении слева и справа появляется концепция факториала, поэтому это рекурсивное определение. Раз так, мы можем написать функцию для вычисления факториала с использованием рекурсивного вызова, код показан ниже.

```python
def fac(num):
    if num in (0, 1):
        return 1
    return num * fac(num - 1)
```

В приведенном выше коде функция `fac` снова вызывает функцию `fac` — это так называемый рекурсивный вызов. Условие `if` во второй строке кода называется условием сходимости рекурсии, проще говоря, это момент, когда нужно завершить рекурсивный вызов функции. При вычислении факториала, если дошли до факториала `0` или `1`, прекращаем рекурсивный вызов и напрямую возвращаем `1`. Строка 4 кода `num * fac(num - 1)` — это рекурсивная формула, то есть рекурсивное определение факториала. Ниже мы кратко проанализируем, каким будет весь процесс, если использовать `fac(5)` для вычисления факториала `5`.

```python
# Рекурсивный вызов функции помещается в стек
# 5 * fac(4)
# 5 * (4 * fac(3))
# 5 * (4 * (3 * fac(2)))
# 5 * (4 * (3 * (2 * fac(1))))
# Остановка рекурсии, функция извлекается из стека
# 5 * (4 * (3 * (2 * 1)))
# 5 * (4 * (3 * 2))
# 5 * (4 * 6)
# 5 * 24
# 120
print(fac(5))    # 120
```

Обратите внимание, что вызов функции сохраняет текущее состояние выполнения кода через структуру данных в памяти, называемую "стеком" (stack), после завершения вызова функции это состояние восстанавливается через эту структуру стека. Стек — это структура данных "первым вошел — последним вышел", что означает, что функция, помещенная в стек первой, вернется последней, а функция, помещенная в стек последней, вернется первой. Например, при вызове функции `a`, в теле выполнения функции `a` вызывается функция `b`, в теле выполнения функции `b` вызывается функция `c`, тогда первой в стек помещается функция `a`, первой из стека извлекается функция `c`. При входе в вызов функции стек увеличивается на один кадр стека (stack frame), кадр стека — это упомянутая нами структура для сохранения текущего состояния выполнения кода; после завершения вызова функции стек уменьшается на один кадр. Обычно пространство стека в памяти невелико, поэтому если рекурсивных вызовов слишком много, это приведет к переполнению стека (stack overflow), поэтому **рекурсивный вызов обязательно должен обеспечить быструю сходимость**. Можем попробовать выполнить `fac(5000)` и посмотреть, не появится ли ошибка `RecursionError` с сообщением: `maximum recursion depth exceeded in comparison` (превышена максимальная глубина рекурсии), фактически произошло переполнение стека.

Если мы используем официальный интерпретатор Python (CPython), по умолчанию максимальная глубина структуры стека вызовов функций установлена на `1000` уровней. Если превысить эту глубину, произойдет упомянутая выше ошибка `RecursionError`. Конечно, можно использовать функцию `setrecursionlimit` модуля `sys` для изменения максимальной глубины рекурсивного вызова, но мы не рекомендуем так делать, потому что обеспечение быстрой сходимости рекурсии — это то, что мы должны делать, иначе следует рассмотреть использование циклической рекуррентности вместо рекурсии.

Приведем еще один пример генерации последовательности Фибоначчи, о котором мы говорили ранее. Поскольку первые два числа последовательности Фибоначчи равны `1`, начиная с третьего числа каждое число является суммой двух предыдущих, можно записать как `f(n) = f(n - 1) + f(n - 2)`, очевидно, это снова рекурсивное определение, поэтому мы можем использовать следующую рекурсивную функцию для вычисления `n`-го числа Фибоначчи.

```python
def fib1(n):
    if n in (1, 2):
        return 1
    return fib1(n - 1) + fib1(n - 2)


for i in range(1, 21):
    print(fib1(i))
```

Нужно напомнить, что хотя код для вычисления чисел Фибоначчи выше выглядит очень простым и понятным, производительность выполнения довольно плохая. Можете попробовать изменить второй параметр функции `range` в цикле `for` на `51`, то есть вывести первые 50 чисел Фибоначчи, посмотрите, сколько времени это займет, приглашаем поделиться временем выполнения кода в комментариях. Что касается того, почему это так медленно, можете сами подумать над причиной. Очевидно, что использование циклической рекуррентности для получения последовательности Фибоначчи — лучший выбор, код показан ниже.

```python
def fib2(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a
```

Кроме того, мы можем использовать функцию `lru_cache` модуля `functools` стандартной библиотеки Python для оптимизации рекурсивного кода выше. Функция `lru_cache` — это декоратор, мы помещаем её над функцией `fib1` выше, она может кэшировать результаты выполнения функции, тем самым избегая большого количества повторных вычислений в процессе рекурсивного вызова, так производительность кода получит "молниеносное" улучшение. Можете попробовать вывести первые 50 чисел Фибоначчи, посмотрите, сколько времени потребуется на выполнение кода после добавления декоратора, встретимся в комментариях!

```python
from functools import lru_cache


@lru_cache()
def fib1(n):
    if n in (1, 2):
        return 1
    return fib1(n - 1) + fib1(n - 2)


for i in range(1, 51):
    print(i, fib1(i))
```

> **Подсказка**: Функция `lru_cache` — это декоратор с параметрами, поэтому в строке 4 кода выше при использовании синтаксического сахара декоратора после `lru_cache` нужно добавить круглые скобки. У функции `lru_cache` есть очень важный параметр `maxsize`, он может использоваться для определения размера пространства кэша, значение по умолчанию — 128.

### Заключение

Декоратор — это особенный синтаксис языка Python, **через декоратор можно расширить существующие функции**, это очень полезный прием программирования. С другой стороны, через рекурсивный вызов функций можно на уровне кода упростить некоторые сложные проблемы, но **при рекурсивном вызове обязательно нужно обращать внимание на условие сходимости и рекурсивную формулу**. Только найдя рекурсивную формулу, есть возможность использовать рекурсивный вызов, а условие сходимости гарантирует, что рекурсивный вызов остановится. Вызов функции сохраняет и восстанавливает состояние через пространство стека в памяти, пространство стека обычно очень мало, поэтому **если рекурсия не сходится быстро, весьма вероятно возникновение ошибки переполнения стека, что приведет к краху программы**.


---
[← Предыдущий урок](16.Продвинутое_использование_функций.md) | Заключительный урок блока 1
