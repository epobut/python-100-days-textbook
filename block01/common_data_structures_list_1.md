## Часто используемые структуры данных: списки-1

Перед началом этого урока давайте дадим вам задачу по программированию: бросить кость 6000 раз и подсчитать, сколько раз выпало каждое значение. Эта задача должна быть очень простой для вас, мы можем использовать случайные числа с равномерным распределением от 1 до 6 для имитации броска кости, затем использовать 6 переменных для записи количества выпадений каждого значения. Полагаю, благодаря предыдущему обучению, вы все сможете довольно гладко написать следующий код.

```python
"""
Бросить кость 6000 раз, подсчитать количество выпадений каждого значения

Author: 骆昊
Version: 1.0
"""
import random

f1 = 0
f2 = 0
f3 = 0
f4 = 0
f5 = 0
f6 = 0
for _ in range(6000):
    face = random.randrange(1, 7)
    if face == 1:
        f1 += 1
    elif face == 2:
        f2 += 1
    elif face == 3:
        f3 += 1
    elif face == 4:
        f4 += 1
    elif face == 5:
        f5 += 1
    else:
        f6 += 1
print(f'1 выпало {f1} раз')
print(f'2 выпало {f2} раз')
print(f'3 выпало {f3} раз')
print(f'4 выпало {f4} раз')
print(f'5 выпало {f5} раз')
print(f'6 выпало {f6} раз')
```

Насколько "уродлив" приведенный выше код, думаю, мне не нужно много говорить. Конечно, еще страшнее то, что если нам нужно бросить две или более костей, а затем подсчитать количество выпадений каждого значения, то потребуется определить еще больше переменных, написать еще больше структур ветвления, и одна мысль об этом вызывает отвращение. На данном этапе, полагаю, у вас уже возник вопрос: есть ли способ использовать одну переменную для хранения нескольких данных, есть ли способ использовать единообразный код для операций с несколькими данными? Ответ положительный, в языке Python мы можем использовать переменные контейнерного типа для хранения и операций с несколькими данными. Сначала мы представим вам список (`list`) — этот новый тип данных.

### Создание списков

В Python **список — это последовательность данных, состоящая из ряда элементов в определенном порядке**, что означает, что если мы определим переменную типа список, **мы можем использовать её для хранения нескольких данных**. В Python можно использовать синтаксис литерала `[]` для определения списка, множество элементов в списке разделяются запятыми, код показан ниже.

```python
items1 = [35, 12, 99, 68, 55, 35, 87]
items2 = ['Python', 'Java', 'Go', 'Kotlin']
items3 = [100, 12.3, 'Python', True]
print(items1)  # [35, 12, 99, 68, 55, 35, 87]
print(items2)  # ['Python', 'Java', 'Go', 'Kotlin']
print(items3)  # [100, 12.3, 'Python', True]
```

> **Примечание**: В списке могут быть повторяющиеся элементы, например, `35` в `items1`; в списке могут быть элементы разных типов, например, в `items3` есть элементы типов `int`, `float`, `str` и `bool`, но мы обычно не рекомендуем помещать элементы разных типов в один список, главным образом потому, что это крайне неудобно для операций.

Мы можем использовать функцию `type` для проверки типа переменной, заинтересованные могут самостоятельно проверить, какого типа переменная `items1`. Поскольку список может хранить несколько элементов, он является контейнерным типом данных, поэтому при именовании переменных типа список обычно используется множественное число.

Кроме того, можно использовать встроенную функцию Python `list` для преобразования других последовательностей в списки. Точнее говоря, `list` — это не обычная функция, это конструктор для создания объектов списка, о концепциях объектов и конструкторов мы расскажем в последующих уроках.

```python
items4 = list(range(1, 10))
items5 = list('hello')
print(items4)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(items5)  # ['h', 'e', 'l', 'l', 'o']
```

> **Примечание**: `range(1, 10)` создает последовательность целых чисел от `1` до `9`, при передаче в конструктор `list` создается список, состоящий из целых чисел от `1` до `9`. Строка — это последовательность символов, `list('hello')` выше использует символы строки `hello` в качестве элементов списка для создания объекта списка.

### Операции со списками

Мы можем использовать оператор `+` для объединения двух списков, операция объединения соединяет элементы двух списков и помещает их в один список, код показан ниже.

```python
items5 = [35, 12, 99, 45, 66]
items6 = [45, 58, 29]
items7 = ['Python', 'Java', 'JavaScript']
print(items5 + items6)  # [35, 12, 99, 45, 66, 45, 58, 29]
print(items6 + items7)  # [45, 58, 29, 'Python', 'Java', 'JavaScript']
items5 += items6
print(items5)  # [35, 12, 99, 45, 66, 45, 58, 29]
```

Мы можем использовать оператор `*` для реализации операции повторения списка, оператор `*` повторяет элементы списка указанное количество раз. Добавим две строки к приведенному выше коду, как показано ниже.

```python
print(items6 * 3)  # [45, 58, 29, 45, 58, 29, 45, 58, 29]
print(items7 * 2)  # ['Python', 'Java', 'JavaScript', 'Python', 'Java', 'JavaScript']
```

Мы можем использовать операторы `in` или `not in` для проверки, находится ли элемент в списке. Добавим еще две строки к приведенному выше коду, как показано ниже.

```python
print(29 in items6)  # True
print(99 in items6)  # False
print('C++' not in items7)     # True
print('Python' not in items7)  # False
```

Поскольку в списке несколько элементов, и элементы размещены в списке в определенном порядке, когда мы хотим оперировать определенным элементом в списке, мы можем использовать оператор `[]`, указав позицию элемента в `[]` для доступа к этому элементу, эта операция называется индексацией. Следует отметить, что позиция элемента в `[]` может быть целым числом от `0` до `N - 1`, а также целым числом от `-1` до `-N`, которые называются прямой индексацией и обратной индексацией соответственно, где `N` представляет количество элементов списка. Для прямой индексации `[0]` получает доступ к первому элементу в списке, `[N - 1]` получает доступ к последнему элементу; для обратной индексации `[-1]` получает доступ к последнему элементу в списке, `[-N]` получает доступ к первому элементу, код показан ниже.

```python
items8 = ['apple', 'waxberry', 'pitaya', 'peach', 'watermelon']
print(items8[0])   # apple
print(items8[2])   # pitaya
print(items8[4])   # watermelon
items8[2] = 'durian'
print(items8)      # ['apple', 'waxberry', 'durian', 'peach', 'watermelon']
print(items8[-5])  # 'apple'
print(items8[-4])  # 'waxberry'
print(items8[-1])  # watermelon
items8[-4] = 'strawberry'
print(items8)      # ['apple', 'strawberry', 'durian', 'peach', 'watermelon']
```

При использовании операции индексации следует избегать выхода индекса за пределы. Для приведенного выше `items8`, если мы обратимся к `items8[5]` или `items8[-6]`, это вызовет ошибку `IndexError`, что приведет к сбою программы, соответствующее сообщение об ошибке: *list index out of range*, что в переводе на русский означает "индекс списка выходит за пределы диапазона". Потому что для списка `items8` из пяти элементов допустимые прямые индексы от `0` до `4`, допустимые обратные индексы от `-1` до `-5`.

Если нужно получить доступ к нескольким элементам списка за один раз, мы можем использовать операцию среза. Операция среза — это оператор вида `[start:end:stride]`, где `start` представляет начальную позицию доступа к элементам списка, `end` представляет конечную позицию доступа к элементам списка (элемент на конечной позиции недоступен), а `stride` представляет шаг, проще говоря, это приращение позиции. Например, если первый элемент, к которому мы обращаемся, находится на позиции `start`, то второй элемент будет на позиции `start + stride`, конечно, `start + stride` должно быть меньше `end`. Добавим следующие операторы к приведенному выше коду для использования оператора среза для доступа к элементам списка.

```python
print(items8[1:3:1])     # ['strawberry', 'durian']
print(items8[0:3:1])     # ['apple', 'strawberry', 'durian']
print(items8[0:5:2])     # ['apple', 'durian', 'watermelon']
print(items8[-4:-2:1])   # ['strawberry', 'durian']
print(items8[-2:-6:-1])  # ['peach', 'durian', 'strawberry', 'apple']
```

> **Напоминание**: Посмотрите на последнюю строку в приведенном выше коде и подумайте, как операция среза получает доступ к элементам, когда шаг отрицательный.

Если значение `start` равно `0`, то при использовании оператора среза его можно опустить; если значение `end` равно `N`, где `N` представляет количество элементов списка, то при использовании оператора среза его можно опустить; если значение `stride` равно `1`, то при использовании оператора среза его также можно опустить. Таким образом, следующий код работает точно так же, как приведенный выше.

```python
print(items8[1:3])     # ['strawberry', 'durian']
print(items8[:3:1])    # ['apple', 'strawberry', 'durian']
print(items8[::2])     # ['apple', 'durian', 'watermelon']
print(items8[-4:-2])   # ['strawberry', 'durian']
print(items8[-2::-1])  # ['peach', 'durian', 'strawberry', 'apple']
```

На самом деле, мы также можем изменять элементы в списке с помощью операции среза, например, добавим еще одну строку к приведенному выше коду, посмотрите на вывод здесь.

```python
items8[1:3] = ['x', 'o']
print(items8)  # ['apple', 'x', 'o', 'peach', 'watermelon']
```

Два списка также могут выполнять операции сравнения, мы можем сравнивать, равны ли два списка, а также сравнивать размеры двух списков, код показан ниже.

```python
nums1 = [1, 2, 3, 4]
nums2 = list(range(1, 5))
nums3 = [3, 2, 1]
print(nums1 == nums2)  # True
print(nums1 != nums2)  # False
print(nums1 <= nums3)  # True
print(nums2 >= nums3)  # False
```

> **Примечание**: У `nums1` и `nums2` выше соответствующие элементы полностью идентичны, поэтому результат операции `==` — `True`. При сравнении `nums2` и `nums3`, поскольку первый элемент `nums2` `1` меньше первого элемента `nums3` `3`, результат сравнения `nums2 >= nums3` — `False`. Операции сравнения двух списков в реальной работе не так часто используются, если действительно не понимаете, просто пропустите, не стоит зацикливаться.

### Обход элементов

Если нужно последовательно извлечь элементы из списка, можно использовать цикл `for-in`, есть два следующих способа.

Способ первый: В циклической структуре через операцию индексации обходить элементы списка.

```python
languages = ['Python', 'Java', 'C++', 'Kotlin']
for index in range(len(languages)):
    print(languages[index])
```

Вывод:

```
Python
Java
C++
Kotlin
```

> **Примечание**: Функция `len` выше может получить количество элементов списка `N`, а `range(N)` образует диапазон от `0` до `N-1`, что как раз подходит в качестве индексов элементов списка.

Способ второй: Напрямую циклически обрабатывать список, переменная цикла является представителем элементов списка.

```python
languages = ['Python', 'Java', 'C++', 'Kotlin']
for language in languages:
    print(language)
```

Вывод:

```
Python
Java
C++
Kotlin
```

### Заключение

На данном этапе мы можем использовать знания о списках для рефакторинга кода "бросок кости и подсчет количества выпадений каждого значения" выше.

```python
"""
Бросить кость 6000 раз, подсчитать количество выпадений каждого значения

Author: 骆昊
Version: 1.1
"""
import random

counters = [0] * 6
# Симуляция броска кости, запись количества выпадений каждого значения
for _ in range(6000):
    face = random.randrange(1, 7)
    counters[face - 1] += 1
# Вывод количества выпадений каждого значения
for face in range(1, 7):
    print(f'{face} выпало {counters[face - 1]} раз')
```

В приведенном выше коде мы используем шесть элементов списка `counters` для представления количества выпадений от 1 до 6, изначально значения всех шести элементов равны 0. Затем мы используем случайные числа с равномерным распределением от 1 до 6 для имитации броска кости. Если выпало 1, значение `counters[0]` увеличивается на 1, если выпало 2, значение `counters[1]` увеличивается на 1, и так далее. Почувствуйте разницу: благодаря использованию типа список плюс циклическая структура, наша обработка данных стала массовой, что делает измененный код намного проще и элегантнее, чем предыдущий.